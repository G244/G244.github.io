{"meta":{"title":"Hexo","subtitle":"","description":"","author":"APWEB庚","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"mysql","slug":"mysql","date":"2020-05-11T02:10:30.000Z","updated":"2020-05-11T02:39:38.592Z","comments":true,"path":"2020/05/11/mysql/","link":"","permalink":"http://yoursite.com/2020/05/11/mysql/","excerpt":"","text":"linux 数据库操作 赋予另台服务器的权限GRANT ALL PRIVILEGES ON . TO ‘用户名‘@’IPv4地址 IDENTIFIED BY ‘密码’ WITH GRANT OPTION;执行 flush privileges;命令立即生效","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"腾讯接口签名方法","slug":"tencent","date":"2020-05-11T02:10:30.000Z","updated":"2020-05-11T02:49:38.434Z","comments":true,"path":"2020/05/11/tencent/","link":"","permalink":"http://yoursite.com/2020/05/11/tencent/","excerpt":"","text":"POST 签名方法V3 /** * 文本内容POST请求参数签名 * @param $action * @param $payload * @return array */ private function signature_post($action, $payload) { $secretId = &quot;腾讯云id&quot;; $secretKey = &quot;腾讯云key&quot;; $host = &quot;cms.tencentcloudapi.com&quot;; $service = &quot;cms&quot;; $version = &quot;2019-03-21&quot;; $region = &quot;ap-guangzhou&quot;; $timestamp = time(); $algorithm = &quot;TC3-HMAC-SHA256&quot;; $httpRequestMethod = &quot;POST&quot;; $canonicalUri = &quot;/&quot;; $canonicalQueryString = &quot;&quot;; $canonicalHeaders = &quot;content-type:application/json; charset=utf-8\\n&quot; . &quot;host:&quot; . $host . &quot;\\n&quot;; $signedHeaders = &quot;content-type;host&quot;; $payload = &apos;{&quot;Limit&quot;: 1, &quot;Filters&quot;: [{&quot;Values&quot;: [&quot;\\u672a\\u547d\\u540d&quot;], &quot;Name&quot;: &quot;instance-name&quot;}]}&apos;; step 1: build canonical request string $hashedRequestPayload = hash(&quot;SHA256&quot;, $payload); $canonicalRequest = $httpRequestMethod . &quot;\\n&quot; . $canonicalUri . &quot;\\n&quot; . $canonicalQueryString . &quot;\\n&quot; . $canonicalHeaders . &quot;\\n&quot; . $signedHeaders . &quot;\\n&quot; . $hashedRequestPayload; step 2: build string to sign $date = gmdate(&quot;Y-m-d&quot;, $timestamp); $credentialScope = $date . &quot;/&quot; . $service . &quot;/tc3_request&quot;; $hashedCanonicalRequest = hash(&quot;SHA256&quot;, $canonicalRequest); $stringToSign = $algorithm . &quot;\\n&quot; . $timestamp . &quot;\\n&quot; . $credentialScope . &quot;\\n&quot; . $hashedCanonicalRequest; step 3: sign string $secretDate = hash_hmac(&quot;SHA256&quot;, $date, &quot;TC3&quot; . $secretKey, true); $secretService = hash_hmac(&quot;SHA256&quot;, $service, $secretDate, true); $secretSigning = hash_hmac(&quot;SHA256&quot;, &quot;tc3_request&quot;, $secretService, true); $signature = hash_hmac(&quot;SHA256&quot;, $stringToSign, $secretSigning); step 4: build authorization $authorization = $algorithm . &quot; Credential=&quot; . $secretId . &quot;/&quot; . $credentialScope . &quot;, SignedHeaders=content-type;host, Signature=&quot; . $signature; return $result = [ &apos;action&apos; =&gt; $action, &apos;version&apos; =&gt; $version, &apos;region&apos; =&gt; $region, &apos;timestamp&apos; =&gt; $timestamp, &apos;httpRequestMethod&apos; =&gt; $httpRequestMethod, &apos;canonicalUri&apos; =&gt; $canonicalUri, &apos;canonicalQueryString&apos; =&gt; $canonicalQueryString, &apos;authorization&apos; =&gt; $authorization, &apos;host&apos; =&gt; $host, &apos;payload&apos; =&gt; $payload ]; }GET 签名方法v1$secretId = &quot;腾讯云id&quot;; $secretKey = &quot;腾讯云key&quot;; $param[&quot;Nonce&quot;] = rand();//rand(); $param[&quot;Timestamp&quot;] = time();//time(); $param[&quot;Region&quot;] = &quot;ap-guangzhou&quot;; $param[&quot;SecretId&quot;] = $secretId; $param[&quot;Version&quot;] = &quot;2019-03-21&quot;; $param[&quot;Action&quot;] = &quot;DescribeTextSample&quot;; //$param[&quot;InstanceIds.0&quot;] = &quot;ins-09dx96dg&quot;; $time =time(); $rand = rand(); ksort($param); $signStr = &quot;GETcms.tencentcloudapi.com/?&quot;; foreach ( $param as $key =&gt; $value ) { $signStr = $signStr . $key . &quot;=&quot; . $value . &quot;&amp;&quot;; } $signStr = substr($signStr, 0, -1); $signature = base64_encode(hash_hmac(&quot;sha1&quot;, $signStr, $secretKey, true)); $signature = urlencode($signature); $param[&apos;Signature&apos;] = $signature; ksort($param); $signStr=&quot;https://cms.tencentcloudapi.com/?&quot;; foreach ( $param as $key =&gt; $value ) { $signStr = $signStr . $key . &quot;=&quot; . $value . &quot;&amp;&quot;; } //去掉&amp; $signStr = substr($signStr, 0, -1); $weather=curl_init(); header(&quot;Content-type: text/html; charset=utf-8&quot;); curl_setopt($weather,CURLOPT_URL,$signStr); curl_setopt($weather,CURLOPT_SSL_VERIFYPEER,false); curl_setopt($weather,CURLOPT_RETURNTRANSFER,1); curl_setopt($weather,CURLOPT_HTTPHEADER,array( &apos;Content-Type:application/x-www-form-urlencoded&apos;, &apos;Host: cms.tencentcloudapi.com&apos;, &apos;charset:utf8&apos; ) ); $data = curl_exec($weather);","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"手写workerman","slug":"handWorkerman","date":"2020-04-08T12:20:30.000Z","updated":"2020-04-09T06:38:15.221Z","comments":true,"path":"2020/04/08/handWorkerman/","link":"","permalink":"http://yoursite.com/2020/04/08/handWorkerman/","excerpt":"","text":"Worker类","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"tp5.1->facade","slug":"facade","date":"2020-04-06T15:30:30.000Z","updated":"2020-06-09T06:33:53.725Z","comments":true,"path":"2020/04/06/facade/","link":"","permalink":"http://yoursite.com/2020/04/06/facade/","excerpt":"","text":"门面模式 facade就是可以把实际类中非静态中的方法通过代理类静态调用，应用解耦，提供了一个静态调用接口，相比于传统的静态方法调用， 带来了更好的可测试性和扩展性松耦合 （是模块之间的联系不会太紧密,独立性比较好,方便后期的管理维护） 继承Facade类 重写方法getFacadeClass方法显式指定要静态代理的类，可以在调用的时候进行动态绑定： common.php文件中 优化配置在config.php=&gt;facade.php 在behavior行为中一个加载行为的类 然后再thinkphp中的tags.php行为扩展文件中 app_init初始化 以上三种方式都OK","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"docker","slug":"docker","date":"2020-04-06T15:30:30.000Z","updated":"2020-06-06T01:54:13.236Z","comments":true,"path":"2020/04/06/docker/","link":"","permalink":"http://yoursite.com/2020/04/06/docker/","excerpt":"","text":"docker命令 docker镜像加速修改daemon.json $ sudo systemctl daemon-reload $ sudo systemctl restart docker 获取镜像 docker pull ubuntu:16.04(版本号) 不加默认为latest 运行容器 docker run -it –rm ubuntu:16.04 bash–rm (当容器退出的时候自动删除)-it -i 交互式操作 -t 终端 查看当前版本系统 cat /etc/os-release 列出镜像 查看所有详情docker image ls 列出id docker image ls -q 自定义列出信息格式 docker image ls --format &quot;{{.ID}}:{{.Repository}}&quot; 表格形式 docker image ls --format &quot;table {{.ID}}\\t{{.Repository}}\\t{{.Tag}}&quot; 镜像体积 docker system df 虚悬镜像(没有仓库名,也没有标签) 查看 docker image ls -f dangling=true 删除 docker image prune 删除本地镜像 用 ID、镜像名、摘要删除镜像 其中，&lt;镜像&gt;可以是 镜像短ID、镜像长ID、镜像名 或者 镜像摘要 。 docker image rm 短ID(ID前3个字符以上) 查看镜像摘要 docker image ls -digests 用docker image ls 命令来配合 docker image rm $(docker image ls -q redis) 定制一个Web服务器 docker run --name webserver -d -p 80:80 nginx 换主页面 docker exec -it webserver bash echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html -d：表示以“守护模式”执行/root/run.sh脚本，此时 Tomcat 控制台不会出现在输出终端上。 -p：表示宿主机与容器的端口映射，此时将容器内部的 8080 端口映射为宿主机的 58080 端口， 这样就向外界暴露了 58080 端口，可通过 Docker 网桥来访问容器内部的 8080 端口了。 修改了容器的文件，也就是改动了容器的存储层 ,可以通过docker diff 容器名 命令看到具体的改动 定制好变化,利用docker commit 可以构成新的镜像docker commit –author “”–message “”webserver nginx:v2 查看镜像的历史记录 docker history nginx:v2 容器设为别名 docker tag redis apweb/redis:v1 COPY 指令将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路 径&gt;位置 仅在需要自动解压缩的场合使用 ADD export 导出容器（小） save 镜像 (大) docker export 7691a814370e &gt; ubuntu.tar import 导入 容器成为了镜像 docker import - test/ubuntu:v1.0 查看容器详情 docker inspect ENTRYPOINT用于指定容器运行程序和参数 CMD 指令就是用于指定默认的容器主进程的启动命令的 创建卷1.VOLUME [“/www”,”/data/mysql”,”/sys/fs/cgroup”] 挂载数据卷2.docker -v 宿主机地址:容器地址 WORKDIR 进入容器默认打开的目录","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"workerman","slug":"workerman","date":"2020-04-01T12:20:30.000Z","updated":"2020-04-09T06:38:15.216Z","comments":true,"path":"2020/04/01/workerman/","link":"","permalink":"http://yoursite.com/2020/04/01/workerman/","excerpt":"","text":"Workerman概念/知识点 TCP 传输层协议TCP是一种面向连接的、可靠的、基于IP的传输层协议 HTTP、WebSocket都属于应用层协议 test协议 协议格式为 数据包+换行符，每个数据包末尾加上一个换行符表示包的结束。 通常开启一个内部端口，方便内部系统推送（硬件通讯/手机App传输数据） 心跳(长连接) //1s 为触发心跳的时间 //$conn 客户端的连接 fd \\Workerman\\lib\\Timer:add(1,function() use ($conn){ //发送给客户端 $conn-&gt;send([&apos;type&apos;=&gt;&apos;ping&apos;]); }) 赋值过程运行在主进程运行在子进程 (假如)1个worker实例有多个进程进程编号id的分配是基于每个worker实例的($worker-&gt;id) 进程数设置原则 如果是IO密集型，也就是业务中涉及到一些阻塞式IO，比如一般的访问Mysql、Redis等存储都是阻塞式访问的，进程数可以开大一些，如配置成CPU核数的3倍。 如果是CPU密集型，也就是业务中没有阻塞式IO开销，例如使用异步IO读取网络资源，进程不会被业务代码阻塞的情况下，可以把进程数设置成和CPU核数一样 设置Worker实例名称($worker-&gt;name) 遍历当前进程所有的客户端连接($worker-&gt;connections as $v) 设置Worker子进程启动时回调的函数onWorkerStart 创立连接获取对方IP：getRemoteIp() 如果想要程序当数量达到max_request使用重新启动一个全新进程(Worker::stopAll()) 此方法主要用于在Worker进程启动后动态创建新的Worker实例，能够实现同一个进程监听多个端口，支持多种协议($worker-&gt;listen()); 将屏幕打印输出到Worker::$stdoutFile指定的文件中(Worker::$stdoutFile)","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"nginx_function","slug":"nginxOther","date":"2020-03-07T12:20:30.000Z","updated":"2020-05-11T02:28:23.438Z","comments":true,"path":"2020/03/07/nginxOther/","link":"","permalink":"http://yoursite.com/2020/03/07/nginxOther/","excerpt":"","text":"负载均衡 nginx反向代理服务器接收到的请求数量，就是我们说的负载量,请求的数量按照一定的规则进行分发,到不同的服务器处理的规则,就是一种均衡规则 将服务器接收到请求按照规则分发的过程,称负载均衡. Nginx 负载均衡调度(upstream)1.weight 默认（轮询）求按照时间顺序轮流分配到不同的后端服务器， 如果某个后端服务器down掉后，能自动剔除。 权重数据越大，则被分配到的服务器请求几率越大 2.ip_hash 一个固定的ip地址总会访问到同一个后端的服务器上,问题是集群部署环境下Session共享的问题 配置：upstream server_name { server **.***.***.***:8080 weight=1; server **.***.***.***:8090 weight=2; }动静分离 当访问静态资源时,路由到一台静态资源服务器,当访问非静态资源时,路由到另外一台服务器 nginx 配置 if (!-e $request_filename) { rewrite ^(.*)$ /index.php?s=/$1 last; break; } location ~ .php(.*) { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_split_path_info ^((?U).+\\.php)(/?.+)$; fastcgi_param HTTPS on; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info; include fastcgi_params; }","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"nginx","slug":"nginx","date":"2020-03-01T12:20:30.000Z","updated":"2020-03-26T11:56:32.000Z","comments":true,"path":"2020/03/01/nginx/","link":"","permalink":"http://yoursite.com/2020/03/01/nginx/","excerpt":"","text":"nginx Nginx是一款轻量级的Web 服务器/反向代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强 正向代理 逻辑：我们将请求发送给代理服务器，代理服务器去访问国外的网站得到的数据再传递给我们，正向代理模式屏蔽或者隐藏了真实客户端信息。 特点：客户端很明确要访问的服务器地址，可以做缓存，加速访问资源 反向代理 逻辑：对于用户而言反向代理服务器相当于目标服务器，访问即可获得目标服务器的数据，反向代理服务器对外是透明的 配置： location / { proxy_pass server_name; } 特点：服务器集群分布式部署(TOMCAT服务器) 负载均衡在一篇中介绍 分布式锁运用：当在高并发的情况下防止发生同样的操作 try{//这个lockKey是否存在存在则添加失败,表示没有执行到删除$result = setnx(‘lockKey’,’suo’); if(!$result){ throw new BaseException(&apos;系统繁忙&apos;); } 业务逻辑代码 }finally{del(‘lockKey’);//删除锁 } 区别 1.在正向代理中，Proxy 和 Client 同属于一个，隐藏了客户端信息。在反向代理中，Proxy 和 Server 同属于一个，隐藏了服务端信息。 2.Proxy 在两种代理中做的事情都是替服务器代为收发请求和响应","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"linux","slug":"linux","date":"2020-03-01T09:20:30.000Z","updated":"2020-05-12T06:42:03.155Z","comments":true,"path":"2020/03/01/linux/","link":"","permalink":"http://yoursite.com/2020/03/01/linux/","excerpt":"","text":"LINUX基础命令查看文件 ls -l 查看文件详情信息 ls -a 查看目录所有文件包括隐藏文件，点开头的就是隐藏文件 ls -al 查看目录所有详细信息文件 包括隐藏文件 用户操作 whoami 我是谁 su -切换用户 $普通用户 exit 退回到原用户 ~是当前用户目录 /是根目录 图形界面与命令界面切换 // # init3 切换到命令界面 // # init5 切换到图形界面 查看一个指令对应的执行程序文件在哪 which 指令 与which不同的是这条命令可以是通过文件索引数据库而非PATH来查找的，所以查找的面比which要广whereis pwd 详细点which pwd 目录的相关操作1)创建目录 make directory mkdir 目录名字 mkdir -p newdir/newdir 创建多个连续新目录 mkdir dir/newdir 移动目录 move mv dir1 dir2 把dir1移动到dir2目录下 mv dir1/dir2 dir3 把dir1下的dir2移动到dir3目录下 mv dir1/dir2 dir3/dir4 把dir1下的dir2 移动到dir3下的dir4下 mv dir1/dir2 ./ 把dir2移动到dir1文件目录下 改名字 mv dir1 newdir dir1改名字为newdir目录复制 cp dir dir1 如果dir含有dir那么就要设置-r[recursive递归]参数，无视目录的层次 cp file dir 复制文件到dir目录 cp file dir/newfile 复制文件到dir目录并改名字为newfile echo “输出内容”&gt;file 在file文件存取内容删除文件和目录 removerm 文件rm -r 目录 -r[recursive递归]递归方式删除目录rm -rf 文件/目录 -r force 递归强制方式删除文件或目录文件操作查看文件内容 cat filename 打印文件内容输出到终端 more filename 通过敲回车方式逐行查看文件的各个行内容默认从第一行开始查看 q退出查看 less 通过上下左右 查看文件的个个内容 q退出查看 -m 显示百分比 -N 显示每行的行号 head -n filename 查看文件的前n行内容 tail -n filename 查看文件的最末尾N行内容 wc filename 查看文件的行数 总数 大小 创建文件touch filename 给文件追加内容// &gt;echo 内容 文件名称 把内容覆盖到文件// &gt;echo 内容 &gt;&gt; 文件追加到文件 linux 另外操作 error_reporting = E_ALL &amp; ~E_DEPRECATED &amp; ~E_STRICT 错误级别 phpize是用来扩展php扩展模块的configure –prefix=/”的作用是：编译的时候用来指定百程序存放路径 。 1，–enable 是启用软件源码包自带 –enable-包名[=arg]，但是默认不启用的功能模块。 2，–with 是指定依赖的资源库的位置 –whit-依赖包名称[=依赖包目录]，如果是默认位置，l路径就可以留空。 ps aux 查看进程 free -m 内存剩余 df -h 磁盘剩余 网络配置 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=eth0 UUID=717998a3-5a00-40ae-961b-746a97470439 DEVICE=eth0 ONBOOT=yes IPADDR=192.168.28.20 NETMASK=255.255.255.0 GATEWAY=192.168.28.1 DNS1=8.8.8.8 DNS2=4.4.4.4 HWADDR=******","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"index","slug":"mIndex","date":"2020-02-27T12:10:30.000Z","updated":"2020-03-26T11:56:32.000Z","comments":true,"path":"2020/02/27/mIndex/","link":"","permalink":"http://yoursite.com/2020/02/27/mIndex/","excerpt":"","text":"索引 索引的一个主要目的就是加快检索表中数据，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"nosql","slug":"nosql","date":"2020-02-24T12:20:30.000Z","updated":"2020-03-25T13:03:30.000Z","comments":true,"path":"2020/02/24/nosql/","link":"","permalink":"http://yoursite.com/2020/02/24/nosql/","excerpt":"","text":"NoSQL 非关系型数据库 （数据与数据之间没有关联关系）数据库四大分类 1.键值存储数据库(Redis,Oracle BDB) 2.列存储数据库-键仍然存在,但它们的特点指向了多个列 （Cassandra HBase） 3.文档数据库-允许之间嵌套键值 (Mong oDb) 4.图形(Graph)数据库 Neo4J 哪种情况下 1.数据模型比较简单 2.需要灵活性更强的IT系统 3.对数据库的性能要求比较高 4.不需高度的数据一致性 5.对于给定key,比较容易映射复杂值的环境。SQL 关系型数据库 (表与表之间建立关联关系)解决大规模数据集合多重数据种类带来的挑战","categories":[],"tags":[{"name":"nosql","slug":"nosql","permalink":"http://yoursite.com/tags/nosql/"}]},{"title":"redis_operate","slug":"redisOpreate","date":"2020-02-24T12:20:30.000Z","updated":"2020-03-25T13:03:02.000Z","comments":true,"path":"2020/02/24/redisOpreate/","link":"","permalink":"http://yoursite.com/2020/02/24/redisOpreate/","excerpt":"","text":"shutdown关闭 redis-cli -hIP地址 -p端口 -a密码 ttl 查看剩余存活时间 pttl 剩余过期时间 persist 移除过期时间 expire 设置存活时间 keys *代表所有 ?表示代表一个字符 select 切换数据库 （0-16） string类型randomkey 返回随机key rename 重命名key move key db 移动到某个数据库 setnx 不存在才赋值 getrange 截取值 mget 获取多个key getset 返回旧值存新值 strlen 长度 incr 自增 decr 自减 incrby 自增多少 -负号减多少 //decrby 自减多少 append 追加值末尾hash类型hash类型 hset存储单个对象 hget 取出 hmset key field存储多个 hmget key field 取多个 hkeys key 获取字段 hlen key 字段数量 hdel key field 删除一个或多个字段 hincrby key field increment -负号减多少 指定的字段整数增量list类型list 类型 lpush 从左侧添加到列表头部 rpush 从右侧添加 lpushx 不存在则无效 lrange key start stop 0 -1获取指定內元素 lindex key index 通过索引获取列表中的元素 lpop 从列表中左侧删除第一个元素 rpop 从列表中右侧删除第一个元素 lrem 删除指定值 blpop key timeout 移除并获取列表第一个元素，如果没有则阻塞列表等到超时或发现元素为止 ltrim key start stop 保留指定起始的元素 lset 通过索引设置列表元素的值 linsert 在列表中元素前或后插入元素 rpoplpush key1 key2 从key1中最后的元素删除到key2开头添加 set类型sadd key member1 memeber2向集合添加一个或多个成员 scard key 返回集合的成员数 smembers key 返回集合所有成员 sismemeber key member 判断memeber元素是否是集合key的成员（注册是否存在） srandmemeber key[count] 返回集合中一个或多个随机数（抽奖） srem key member删除集合一个或多个成员 spop key count 随机删除规定数量的集合成员并返回 smove 集合1 集合2 成员 将成员从集合1移到集合2 sdiff key1 key2 返回差集 sdiffstore jihe 存到jihe sinter key1 key2 返回交集 sinterstore jihe 存到jihe sunion key1 key2 返回并集 sunionstore jihe 存到jihezSet类型zadd key score memeber 向有序集合中添加成员 zcard key 返回集合成员数 zcount key min max 在指定分数内的成员数量 zrange key start stop 返回指定起始的成员（低-高） zrevrange key start stop （高-低） zrank key member 查询所在集合中的索引值 zrem key member 移除有序集合中的成员或多个成员 zremrangebyrank key start stop 通过起始下标删除成员 zremrangebyscore key min max 移除有序集合的分数区间的成员","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}]},{"title":"redis_install_conf","slug":"redisInstall","date":"2020-02-24T12:20:30.000Z","updated":"2020-03-25T13:03:10.000Z","comments":true,"path":"2020/02/24/redisInstall/","link":"","permalink":"http://yoursite.com/2020/02/24/redisInstall/","excerpt":"","text":"redis安装1.安装gcc redis是c语言编写的 yum install gcc-c++2.下载redis安装包,在root目录下执行 wget http://download.redis.io/releases/redis-5.0.4.tar.gz3.解压redis安装包 tar -zxvf redis-5.0.4.tar.gz 4.进入redis目录 cd redis-5.0.4 5.编译 make 6.安装 make PREFIX=/usr/local/redis install redis.conf配置daemonize no 改为 yes 启动守护进程 pidfile 指定pid timeout 300 闲置时间关闭 为0表示关闭 databases 连接数据库数量 save 900 1 持久化时间900秒有一个更改执行 dbifilename 持久化数据库名 dir ./ 本地数据库存放目录 requirepass 设置密码 maxclients 客户连接数 maxmemory 内存最大设置","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}]},{"title":"redis_function","slug":"redisFunction","date":"2020-02-24T11:20:30.000Z","updated":"2020-03-25T13:02:32.000Z","comments":true,"path":"2020/02/24/redisFunction/","link":"","permalink":"http://yoursite.com/2020/02/24/redisFunction/","excerpt":"","text":"订阅频道:subscribe channel 关注一个或多个频道 publish channel message 将信息发送到指定频道 unsubscribe 退订多数据库select 切换 move key db 移动键值到另一个数据库 flushdb 清除当前数据库的所有key flushall 清楚整个redis的数据库所有key事务multi 事务开始 输入的命令都会进入队列中 exec 之前的队列中依次执行 discard 取消事务 watch 监视key 如果在事务执行中 这个key有所改动 则事务回滚 unwatch 取消watch对所有key的监视","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}]},{"title":"curl","slug":"curl","date":"2020-02-15T08:20:30.000Z","updated":"2020-05-11T08:58:52.914Z","comments":true,"path":"2020/02/15/curl/","link":"","permalink":"http://yoursite.com/2020/02/15/curl/","excerpt":"","text":"curlGET请求 $c = curl_init(); //初始化curl句柄 curl_setopt($c,CURLOPT_URL,’http://localhost/ss/text1.php?id=1&#39;); //设置一个curl传输选项 设置请求的url curl_setopt($c,CURLOPT_RETURNTRANSFER,1);//将curl_exec()获取的信息以文件流的形式返回，而不是直接输出; $curl = curl_exec($c); //执行一个curl句柄 curl_close($c); var_dump($curl); curlPOST请求 $c = curl_init(); $url = ‘HTTP://localhost/ss/text2.php’; $post_data = [‘username’=&gt;’nihaolaoshi’]; curl_setopt($c,CURLOPT_URL,$url); curl_setopt($c,CURLOPT_RETURNTRANSFER,1); curl_setopt($c,CURLOPT_POST,1); curl_setopt($c,CURLOPT_POSTFIELDS,$post_data); $curl = curl_exec($c); curl_close($c); var_dump($curl); curl函数与服务器使用各种类型的协议进行连接和通信的 curl_setopt()常用选项 CURLOPT_URL 需要获取的URL地址,也可以在curl_init初始化 CURLOPT_POST 启用时会发送一个常规的POST请求，类型为：application/x-www-form-urlencoded，就像表单提交的一样。 CURLOPT_SSL_VERIFYPEER 禁用后cURL将终止从服务端进行验证 CURLOPT_SSL_VERIFYHOST 1 检查服务器SSL证书中是否存在一个公用名(common name)。译者注：公用名(Common Name)一般来讲就是填写你将要申请SSL证书的域名 (domain)或子域名(sub domain) CURLOPT_HTTPHEADER 一个用来设置HTTP头字段的数组 CURLOPT_HEADER 启用时会将头文件的信息作为数据流输出。 CURLOPT_USERAGENT 在HTTP请求中包含一个”User-Agent: “头的字符串 此后微软开发了自己的浏览器，这就是Internet Explorer Mozilla/5.0： 网景公司浏览器的标识 Mozilla中文名称摩斯拉。更名为Netscape 多增加一些字段都是为了让服务器检测到它支持的浏览器标识，以便获得服务器的响应 CURLOPT_FOLLOWLOCATION 启用时会将服务器服务器返回的”Location: “放在header中递归的返回给服务器 CURLOPT_AUTOREFERER 自动设置header中的referer信息 CURLOPT_POSTFIELDS 全部数据使用HTTP协议中的”POST”操作来发送 CURLOPT_RETURNTRANSFER 将curl_exec()获取的信息以文件流的形式返回 CURLOPT_POST 启用时会发送一个常规的POST请求，类型为：application/x-www-form-urlencoded，就像表单提交的一样 CURLOPT_CUSTOMREQUEST 使用一个自定义的请求信息来代替”GET”或”HEAD”作为HTTP请求 设置CURLOPT_FOLLOWLOCATION为true，则会跟踪爬取重定向页面，否则，不会跟踪重定向页面。","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"设计模式","slug":"phpDesign","date":"2020-02-15T08:20:30.000Z","updated":"2020-03-26T12:02:08.000Z","comments":true,"path":"2020/02/15/phpDesign/","link":"","permalink":"http://yoursite.com/2020/02/15/phpDesign/","excerpt":"","text":"design patterns单例模式 如何在整个项目创建唯一对象的实例(数据库连接) 工厂模式 如何不通过new建立实例对象 策略模式 将一组制定行为和算法封装成类 适配器模式 将各种不同函数接口封装成统一API 注册模式 将对象注册到全局树上","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"regular","slug":"preg","date":"2020-01-08T08:20:30.000Z","updated":"2020-03-25T13:12:58.000Z","comments":true,"path":"2020/01/08/preg/","link":"","permalink":"http://yoursite.com/2020/01/08/preg/","excerpt":"","text":"正则表达式##字符串规则表达式-&gt;正则表达式 pattern 要搜索的模式,字符串形式 subject 输入字符串 matches 多维数组,作为输出参数输出所有匹配结果 preg_match_all($pattern,$subject,$matches)具体字符(字面值) 字符边界 _^匹配字符串的开始 -$匹配字符串的结尾 &emsp; $pattern = ‘/^hi$/‘ -\\b匹配单词的开始和结尾 -\\B 匹配单词的非边界 &emsp; $pattern = ‘/\\bhi\\b/‘ | ‘/\\Bhi/‘ 字符集合 [ace],[0123456789] &emsp; $pattern = ‘/[ace]/‘ 字符补集 [^qxz]:不在qxz范围內 &emsp; $pattern = ‘/[^ace]/‘ 字符范围 [a-z 0-9] &emsp; $pattern = ‘/[a-z]/‘字符簇(系统定义好的常用集合) 簇 代表 \\w &emsp; [a-z A-Z 0-9_] &emsp; $pattern = ‘/\\w+/‘ \\W &emsp; \\w的补集 &emsp; $pattern = ‘/\\W+/‘ 分割空白符 \\s &emsp; 空白符,包括\\n\\r\\t\\v等 $pattern = ‘/\\s+/‘ 空白符 \\S &emsp; 非空白符 \\d &emsp; [0-9] \\D &emsp; 非数字 *匹配前面的子表达式零次或多次 +匹配前面的子表达式一次或多次 ?匹配前面的子表达式零次或一次 {n}n是一个非负整数。匹配已确定的n次 {n,m} m和n均为非负整数,其中n&lt;=m,最少匹配前面n次且最多匹配m次 {n,}n是一个非负整数。至少匹配n次贪婪模式(会尽量多的匹配) 在数量(+ * {n,})限定符后加? 非贪婪模式 i模式 不区分大小写 s模式 将所有内容看成一整行 u模式 把传入的参数看成是unicode字符集的编码,可以判断中文，u模式,\\x{4e00}-\\x{9fa5}例子 $pattern = ‘/\\b[a-zA-Z]+\\b|\\b\\d+\\b/‘; &emsp; // |是正则表达式里面的或者8 $pattern = ‘/\\bi(phone|mac|pad)\\b/‘; &emsp; //括号里的是子表达式 也要进行匹配9 $pattern = ‘/g.+d/‘; &emsp; //贪婪模式10 $pattern = ‘/g.+?d/‘; &emsp; //非贪婪模式11 $pattern = ‘/1[3458][0-9]{9}/‘; &emsp; //采集手机号12 $pattern = ‘/([a-zA-Z])\\w+\\1/‘; &emsp; //反向引用13 $pattern = ‘/(\\d{3})\\d+(\\d{4})/‘; &emsp; //$str1 = preg_replace($pattern,’\\1****\\2’,$str); $pattern = ‘/[a-z]+/i’; &emsp; //i不区分大小写 $pattern = ‘/.+/s’; &emsp; singled单行模式 将所有内容看成一整行 $pattern = ‘/^[\\x{4e00}-\\x{9fa5}]+$/u’; $pattern = ‘/\\b\\w+(?!ing)\\w{3}\\b/‘; &emsp; //预查 后面3个字母不是ing的单词 $pattern = ‘/\\b\\w+(?=ing\\b)/‘; &emsp; //预查 单词ing前面的字母 $pattern = ‘/un(\\w+)/‘; &emsp; //查找un开头的单词 $pattern = ‘/(?&lt;=\\bun)\\w+\\b/‘; &emsp; //预查 un开头后的字母 $pattern = ‘/\\b\\w{2}(?&lt;!un)\\w+\\b/‘; &emsp; //预查 不是un开头的单词","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"redis","slug":"redis","date":"2020-01-05T14:48:32.000Z","updated":"2020-03-26T11:58:30.000Z","comments":true,"path":"2020/01/05/redis/","link":"","permalink":"http://yoursite.com/2020/01/05/redis/","excerpt":"","text":"RedisRedis 是完全开源免费的,遵守BSD协议，是一个高性能(NOSQL)的key_value数据库key-value 缓存产品的特点： 1.Redis支持数据的持久化，可以将内存中的数据保存到磁盘中 2.同时还提供list,set,zset,hash等数据结构的存储 3.支持数据的备份(master-slave) ,集群等高可用功能（支持16个库） 4.消息队列（聊天室） 5.单线程，原子性redis类型1.string类型是二进制安全的 可以包含任何数据 二进制安全特点:编码，解码发生在客户端完成，执行效率高,不需要频繁编解码,不会出现乱码 2.hash类型存储值对象(2^32-1)40多亿个,储存一个用户对象数据 3.list类型可以存入多个值（适合） ~~对数据量大的集合数据删减 列表数据显示(分页)、关注列表、粉丝列表、留言评价、热点新闻（top5） ~~任务队列 订单系统下单流程、用户系统登录注册短信 4.set类型 是唯一，无序集合 共同关注、共同喜好、二度好友 唯一性统计访问网站的独立IP 5.zset类型，是唯一，有序集合 排行榜，权重的队列(任务计划)BSD协议开源协议是给使用者很大的自由协议string hash list set Zset hyper log logredis订阅发布即时聊天、群聊 粉丝关注你，你发消息推送消息给粉丝Redis 事务1.执行命令错误不会进行回滚,则是报出错的信息，其他命令依旧执行 2. 如果是命令语法错误,执行后则进行回滚 商品秒杀、转账活动Redis 数据淘汰策略 ## Redis 持久化 RDB机制 dump.rdb 以快照的方式写入到二进制文件🀄 快照保存数据快，还原数据快 Redis 缓存与数据库Redis 缓存与数据库(Mysql)同步–》使用的是kafka做为异步队列Redis知识点总结 :缓存穿透、缓存雪崩、热点key等处理方案(会双重锁的使用)","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}]},{"title":"$this class new 关系原理","slug":"insideoop","date":"2020-01-05T03:20:11.000Z","updated":"2020-04-03T15:56:00.000Z","comments":true,"path":"2020/01/05/insideoop/","link":"","permalink":"http://yoursite.com/2020/01/05/insideoop/","excerpt":"","text":"$this 内部对象,代表访问该方法的外部对象 执行代码运行是放到内存运行 内存(栈区) 小、效率高 内存(堆区)放大数据的 内存(数据段) 放数据的 内存(代码段)运行必须加载到代码段 执行步骤 类结构不会执行 实例化类先去代码段找类是否存在, 不存在则报错 实例化的过程会在堆里面产生一个内存区， 复制所有属性指向这个类 执行方法把放到内存的栈区, 开始执行的时候会产生局部变量$this 然后去找谁来访问我， 然后找到指向复制的对象， $this就等于外部实例化的变量 （指向同一内存地址、代表同一个对象） 就知道是谁指向的，然后栈里面有个环境 是属于类的内部","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"oop thought keywords","slug":"ooptwo","date":"2020-01-05T03:00:00.000Z","updated":"2020-04-03T15:56:00.000Z","comments":true,"path":"2020/01/05/ooptwo/","link":"","permalink":"http://yoursite.com/2020/01/05/ooptwo/","excerpt":"","text":"面向对象的关键字用法 静态延迟绑定 是为了明确访问的主体 self::$name,&apos;&lt;/br&gt;&apos;;#编译时本身对象::$name; static::$name; #编译时?::$name; 最终类 final关键字修饰的类表示无法被继承 修饰方法表示该方法不能被重写 可以在一个更高的维度来保证同类事务的共同表现 作用：限制类被继承，从而保护结构 抽象类 abstract关键字修饰的类，表示该类不能被实例化，只能被继承 规范类结构，从而保证开发一致性 父类为抽象则子类也要为抽象类， 而想去实现则实现(重写)这方法 trait 代码的复用 为类似php单继承提供的一个代码复用机制 trait的结构类似与类有属性和方法，不能有常量 trait权限修改: 方法名 as 访问修饰限定符 trait同名: trait同名现象使用instead of 替换另外一个 或者 替换后让另外一个使用别名 例如: use t2,t1{ t2::eat insteadof t1; t1::eat as show; }同名属性:(除非同名同值) 同名方法 trait优先级当有同名情况下子类&gt;trait&gt;父类 interface 接口成员 接口是一个与类相似的结构，目的是为了规范一些类的必要行为 接口成员只有两类: 接口常量：const 公有的接口方法 接口方法没有方法体，都为抽象方法 实现接口，实体类 class People implements Man 不能进行重写 接口会使得项目开发变得不那么灵活、多使用在大型项目规范团队得协作,从而从最上层规范整体架构 接口继承子接口、接口多继承 interface faceExam extends EnglishExam,MathExam 目的：实现接口的扩展：丰富接口内容，从而实现更好的对实现类的规范 overload php中的重载： 属性重载：属性方法不存在或者权限不够自动触发 属性重载魔术方法： __get()访问不存在或者权限不够的属性的时候 __set()设置不存在或者权限不够的属性的时候 __isset()判定不存在或者权限不够的属性的时候 __unset()删除不存在或者权限不够的属性的时候 保证数据安全性、不让代码出先操作性错误 有效保证对象结构、不会用户无限增加对象属性 方法重载： 方法不存在或者权限不够自动触发 (容错处理) /* @$name 为调用方法的名称 @$arguments 为传来的数组 */ __call($name,$arguments) __callStatic$name,$arguments) 对象遍历(把内容全部遍历出来) Iterator迭代器 遍历控制 专门针对有遍历对象控制的类而存在的 有效控制foreach对对象的遍历，从而保护好内部结构 /迭代器Iterator/ private $property = [ &apos;name&apos;=&gt;&apos;nihao&apos;, &apos;age&apos;=&gt;&apos;&apos;, &apos;weight&apos;=&gt;&apos;&apos;, &apos;height&apos;=&gt;&apos;&apos;, &apos;hair&apos;=&gt;&apos;&apos; ]; /*数组下标指针不变时*/ // private $key = 0; /*取出当前数组元素值*/ public function current() { return current($this-&gt;property); // return $this-&gt;property[$this-&gt;key]; } /*返回当前下标*/ public function key() { return key($this-&gt;property); // return $this-&gt;key; } /*当前下标+1*/ public function next() { next($this-&gt;property); // $this-&gt;key++; } /*判断下标对应的元素是否存在*/ public function valid() { return isset($this-&gt;property[key($this-&gt;property)]); // return isset($this-&gt;property[$this-&gt;key]); } /*重置数组下标*/ public function rewind() { reset($this-&gt;property); // $this-&gt;key = 0; } } $property = new diedai(); foreach ($property as $key =&gt; $value) { echo $key . &apos;:&apos; . $value,&apos;&lt;br&gt;&apos;; } * Generator生成器 * 生成器是一种实现了Iterator迭代器接口的类 * 生成器的目的是利用yield关键字实现循环内部的暂停 function generator(){ for($i=0;$i&lt;10000;$i++){ yield $i; } } echo memory_get_usage(),&apos;&lt;br&gt;&apos;;#358122 /*自动返回对象*/ $arr = generator(); foreach($arr as $key=&gt;$value){ // echo $value.PHP_EOL; } namespace命名空间 space 非限定名称访问 限定名称访问 space1\\display(); 完全限定名称访问 \\space\\display(); 系统函数和常量，系统会自动升级到全局控制找 系统类不会 要访问则去全局空间找加\\ autoload自动加载 function my_autoload($classname) { if (!class_exists($classname)) { $file = $classname.&apos;.php&apos;; if(file_exists($file)){ include $classname . &apos;.php&apos;; } } return true; } spl_autoload_register(&apos;my_autoload&apos;);","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"oop thought","slug":"oop","date":"2020-01-05T02:20:11.000Z","updated":"2020-04-03T15:56:00.000Z","comments":true,"path":"2020/01/05/oop/","link":"","permalink":"http://yoursite.com/2020/01/05/oop/","excerpt":"","text":"面向对象 机器语言：即开发者(科学家)使用0和1组成命令,然后在特定的计算机上执行 优点：执行效率高 缺点：开发难度大，移植性差，开发成本高 汇编语言：开发者使用简洁的英文字母和符号组成 高级计算机语言： 面向过程编程：将要解决的功能分解成具体的步骤，然后通过函数编程实现面一个步骤,最后通过函数规定好的顺序调用完成 面向过程编程思想的优点 能够针对步骤拆分，进行模块化封装 可以实现代码的复用，降低开发的成本 面向过程编程思想的缺点 不够灵活维护，流程一旦确定就必须按照既定的方式顺序执行到底 面向对象是基于面向过程之上,也是根据功能需求封装，还有事务操作的主体，即对象 面向对象是一种编程思想，其本质是建立模型体现出来的抽象思维过程和面向对象的方法。模型是用来反映现实世界的事物特征开发规范: 开发者约定俗称的开发设计方式 属性初始化 访问修饰限定符选择 类 类成员(member)：{ 成员变量(property) 成员方法(method) 常量(const)} 打印对象：object(Nothing)#1(0){} object:对象 (Nothing)：所属类名 #1是整个脚本中对象编号 (0)成员变量(属性)个数 {}具体成员变量信息（键值对） 封装将数据元素和行为进行结合,类负责处理业务数据逻辑，对象负责调用实现 继承有限继承2. 单继承3. 链式继承 * 私有不会被覆盖 * 重写时控制权限不能高于父类 * 可以通过在子类方法中使用parent关键字来强制访问父类方法多态多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息将可以产生不同的结果，这种现象称为多态性。 class employee{//定义员工父类 protected function working(){//定义员工工作，需要在子类的实现 echo &quot;本方法需要在子类中重载!&quot;; } } class painter extends employee{//定义油漆工类 public function working(){//实现继承的工作方法 echo &quot;油漆工正在刷漆！\\n&quot;; } } class typist extends employee{//定义打字员类 public function working(){ echo &quot;打字员正在打字！\\n&quot;; } } class manager extends employee{//定义经理类 public function working(){ echo &quot;经理正在开会！&quot;; } } function printworking($obj){//定义处理方法 if($obj instanceof employee){//若是员工对象，则显示其工作状态 $obj-&gt;working(); }else{//否则显示错误信息 echo &quot;Error: 对象错误！&quot;; } } printworking(new painter());//显示油漆工的工作 printworking(new typist());//显示打字员的工作 printworking(new manager());//显示经理的工作","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"common_function","slug":"array","date":"2019-12-27T08:20:30.000Z","updated":"2020-05-11T02:34:36.435Z","comments":true,"path":"2019/12/27/array/","link":"","permalink":"http://yoursite.com/2019/12/27/array/","excerpt":"","text":"常用数组的函数 array_push()将数组插入一个数组的末端array_push($a,$b); array_intersect 比较两个数组的键值,并返回交集 (交集的键名是一第一个数组的键名) array_intersect_assoc 比较两个数组的键值和键名,并返回交集 array_merge 是进行两个数组合并 但后面的数组相同的键名会覆盖掉前面的值 array_merge_recursive 也是进行两个数组合并,但相同的键名的值会递归成一个数组 array_slice(array,start,length,preserve) 分页 preserve 默认为false(重置键名) true(不重置) array_column(二维数组,返回的字段,字段对应的key值) arrays_key()返回数组的键 in_array()一个值在数组中是否存在 array_chunk(array,size,false默认/true 保留原数组的键名) 把数组分割为带有两个元素的数组块： size 必需。一个整数，规定每个新数组块包含多少个元素。 explode()把字符串转换为数组 implode()把数组转换为字符串 urlencode是一个函数，可将字符串以URL编码 ini_set(‘memory_limit’, ‘128M’);内存设置 JSON=&gt;数组 json_encode()用于对变量进行json编码 json_decode()对json格式的字符串进行解码转换为PHP变量 assoc当参数为false返回对象 字符串 substr($a,1,3)在$a个字符串的1位置开始3结束 str_shuffle()打乱字符串顺序 str_split()把字符串分割到数组中 str_pad($a,5,’.’)在$a字符串填充不足5位数的点 str_replace()替换字符 strip_tags()允许存在指定标签 stristr($str,’str’)字符串比较看是否存在存在返回str _toString()的函数，可以用来返回表示对象的字符串信息该函数是不区分大小写的。如需进行区分大小写的搜索，请使用strstr()函数。 Url操作 parse_url() 结果query参数内容 path路径内容","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"电商小程序","slug":"hello-world","date":"2019-12-21T12:20:30.000Z","updated":"2020-04-09T06:44:05.179Z","comments":true,"path":"2019/12/21/hello-world/","link":"","permalink":"http://yoursite.com/2019/12/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"git","slug":"gitb笔记","date":"2019-12-20T14:48:32.000Z","updated":"2020-03-26T11:56:32.000Z","comments":true,"path":"2019/12/20/gitb笔记/","link":"","permalink":"http://yoursite.com/2019/12/20/gitb%E7%AC%94%E8%AE%B0/","excerpt":"","text":"PHP是世界上最好的语言 TP5上传图片 合并分支git merge origin/分支名称 切换分支git checkout 分支名称 合并分支取消git reset –hard head公钥 删除 .ssh 文件夹【C:\\Users(本地用户名).ssh】 中的 known_hosts(直接删除即可) 在下载好的Git中的bin目录下（一般是 C:\\Program Files\\Git\\bin）打开bash.exe输入命令ssh-keygen -t rsa -C “username” (注：username为你git上的用户名)，如果执行成功。返回： Generating public/private rsa key pair. Enter file in which to save the key (/Users/username/.ssh/id_rsa): //这里的username是电脑上的用户名，这个地址也是文件的存储地址，然后按回车，如果以前有存储地址会返回/Users/your username/.ssh/id_rsa already exists.Overwrite (y/n)?直接输入y回车。 如果以前没有储存地址就会出现Enter passphrase(empty for no passphrase);也直接回车， 两种情况回车后都会出现 Enter same passphrase again 然后接着回车会显示 然后找到系统自动在.ssh文件夹下生成两个文件，id_rsa和id_rsa.pub，用记事本打开id_rsa.pub将全部的内容复制。 然后将你复制的内容粘贴到key中 仍然在bash.exe中输入ssh -T git@gitee.com/git@github.com然后会跳出一堆内容你只需输入yes回车就完事了，然后他会提示你成功了","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"解析域名流程","slug":"host","date":"2019-02-21T12:20:30.000Z","updated":"2020-05-11T07:20:40.610Z","comments":true,"path":"2019/02/21/host/","link":"","permalink":"http://yoursite.com/2019/02/21/host/","excerpt":"","text":"域名1、用户发起请求 2、apache 解析本次请求的域名和端口号， 加载 httpd-vhosts.conf 中的规则 3、检查是否存在与本次请求 端口号 一致的规则，存在 3， 不存在 4 3、进一步检查 规则中是否存在 ServerName 与本次请求 域名一致的规则，若存在做对应处理【完全匹配】；若不存在，则取第一条端口号一致的规则作为处理【至少端口号一致也会被拦截下来】 4、虚拟主机规则匹配完全失败，则读取 httpd.conf 中定义的 DocumentRoot 作为规则处理请求","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]}],"categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"nosql","slug":"nosql","permalink":"http://yoursite.com/tags/nosql/"},{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]}